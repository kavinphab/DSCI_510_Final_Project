{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2572bf2f-79ba-4a80-94c9-32cb62373a22",
   "metadata": {},
   "outputs": [],
   "source": [
    "from get_data import download_nfl_data, download_cfb_data\n",
    "from clean_data import clean_nfl_team_stats, clean_cfb_player_stats\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6dfd2c66-94e7-4804-837d-4025eb4f20a0",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "PROC_DIR = os.path.join(\"data\", \"processed\")\n",
    "RESULTS_DIR = \"results\"\n",
    "\n",
    "\n",
    "def _ensure_dir(path: str) -> None:\n",
    "    #create folder path if does not exist already\n",
    "    \n",
    "    os.makedirs(path, exist_ok=True)\n",
    "\n",
    "\n",
    "def load_nfl_data(season: int = 2024) -> None:\n",
    "    \"\"\"\n",
    "    Loading NFL data from API calls into csv raw data files\n",
    "\n",
    "    Parameters\n",
    "    ----------\n",
    "    season : int, optional\n",
    "        Data from which season should be obtained from API call.\n",
    "\n",
    "    Returns\n",
    "    -------\n",
    "    NoneType\n",
    "        saves raw data to external file\n",
    "    \"\"\"\n",
    "    league_path = os.path.join(PROC_DIR, f\"nfl_team_stats_{season}.csv\")\n",
    "    bears_path = os.path.join(PROC_DIR, f\"bears_team_stats_{season}.csv\")\n",
    "    league_df = pd.read_csv(league_path)\n",
    "    bears_df = pd.read_csv(bears_path)\n",
    "    return league_df, bears_df\n",
    "\n",
    "\n",
    "def standardize_metrics(league_df: pd.DataFrame, bears_df: pd.DataFrame) -> pd.DataFrame:\n",
    "    \"\"\"\n",
    "    Compute z scores for bears stats by comparing to the rest of the league\n",
    "\n",
    "    Parameters\n",
    "    ----------\n",
    "    season : int, optional\n",
    "        Data from which season should be obtained from API call.\n",
    "\n",
    "    Returns\n",
    "    -------\n",
    "    NoneType\n",
    "        saves raw data to external file\n",
    "    \"\"\"\n",
    "    numeric_cols = league_df.select_dtypes(include=[np.number]).columns\n",
    "    means = league_df[numeric_cols].mean()\n",
    "    stds = league_df[numeric_cols].std(ddof=0)\n",
    "\n",
    "    bears_row = bears_df.iloc[0][numeric_cols]\n",
    "    z_scores = (bears_row - means) / stds\n",
    "\n",
    "    z_df = (\n",
    "        pd.DataFrame({\"metric\": numeric_cols, \"z_score\": z_scores.values})\n",
    "        .sort_values(\"z_score\")\n",
    "        .reset_index(drop=True)\n",
    "    )\n",
    "    return z_df\n",
    "\n",
    "\n",
    "def map_metric_to_position(metric_name: str) -> str:\n",
    "    \"\"\"\n",
    "    Renaming and recatagorizing positions\n",
    "    If it does not if any of the positions it is classified as other\n",
    "\n",
    "    Parameters\n",
    "    ----------\n",
    "    season : int, optional\n",
    "        Data from which season should be obtained from API call.\n",
    "\n",
    "    Returns\n",
    "    -------\n",
    "    String\n",
    "        Expanded name for position\n",
    "    \"\"\"\n",
    "    name = metric_name.lower()\n",
    "    if \"pass\" in name or \"qb\" in name:\n",
    "        return \"QB / Passing Offense\"\n",
    "    if \"rush\" in name or \"rushing\" in name:\n",
    "        return \"RB / Rushing Offense\"\n",
    "    if \"rec\" in name or \"receiving\" in name:\n",
    "        return \"WR/TE Receiving\"\n",
    "    if \"sack\" in name or \"sacks\" in name:\n",
    "        return \"Pass Rush / DL\"\n",
    "    if \"interception\" in name or \"int\" in name or \"defense\" in name:\n",
    "        return \"Defense / Secondary\"\n",
    "    if \"punt\" in name or \"kick\" in name or \"special\" in name:\n",
    "        return \"Special Teams\"\n",
    "    return \"Other/Unknown\"\n",
    "\n",
    "\n",
    "def infer_position_needs(z_df: pd.DataFrame) -> pd.DataFrame:\n",
    "    \"\"\"\n",
    "    Takes a look at z scores and sorts to find position needs\n",
    "\n",
    "    Parameters\n",
    "    ----------\n",
    "    z_df : dataframe,\n",
    "        unsorted z score data frame for bears by position metrics\n",
    "\n",
    "    Returns\n",
    "    -------\n",
    "    Dataframe\n",
    "        Cleaned dataframe with sorted z scores\n",
    "    \"\"\"\n",
    "    z_df[\"position_group\"] = z_df[\"metric\"].apply(map_metric_to_position)\n",
    "    group_df = (\n",
    "        z_df.groupby(\"position_group\", as_index=False)[\"z_score\"]\n",
    "        .mean()\n",
    "        .sort_values(\"z_score\")\n",
    "    )\n",
    "    return group_df\n",
    "\n",
    "\n",
    "def pick_top_need_positions(group_df: pd.DataFrame, k: int = 3) -> list[str]:\n",
    "    \"\"\"\n",
    "    Picking top positional needs based on z scores\n",
    "\n",
    "    Parameters\n",
    "    ----------\n",
    "    group_df : dataframe\n",
    "        Data from which season should be obtained from API call.\n",
    "\n",
    "    k: dataframe, optional:\n",
    "       number of top positions chosen \n",
    "\n",
    "    Returns\n",
    "    -------\n",
    "    String list\n",
    "        List of top k positions needed\n",
    "    \"\"\"\n",
    "    top_k = group_df.sort_values(\"z_score\").head(k)\n",
    "    print(\"Top position groups of need:\")\n",
    "    for _, row in top_k.iterrows():\n",
    "        print(f\"  - {row['position_group']} (avg z = {row['z_score']:.2f})\")\n",
    "    return top_k[\"position_group\"].tolist()\n",
    "\n",
    "\n",
    "def load_cfb_stats(year: int = 2024) -> pd.DataFrame:\n",
    "    \"\"\"\n",
    "    Taking college football stats and converting to csv to correct path\n",
    "\n",
    "    Parameters\n",
    "    ----------\n",
    "    year : int, optional\n",
    "        Data from which season data is from\n",
    "\n",
    "    Returns\n",
    "    -------\n",
    "    Dataframe\n",
    "        Dataframe saved as csv type to defined file path\n",
    "    \"\"\"\n",
    "    path = os.path.join(PROC_DIR, f\"cfb_player_stats_{year}.csv\")\n",
    "    if not os.path.exists(path):\n",
    "        print(f\"[CFB] Missing processed player stats: {path}\")\n",
    "        return pd.DataFrame()\n",
    "    return pd.read_csv(path)\n",
    "\n",
    "\n",
    "def filter_prospects_for_position(cfb_df: pd.DataFrame, need_group: str) -> pd.DataFrame:\n",
    "    \"\"\"\n",
    "    Matching bears needed positions to select relevant college prospects\n",
    "\n",
    "    Parameters\n",
    "    ----------\n",
    "    cfb_df : dataframe\n",
    "        full college players dataframe\n",
    "\n",
    "    need group: string:\n",
    "       what is needed by bears and selecting all college players in those positions \n",
    "\n",
    "    Returns\n",
    "    -------\n",
    "    Dataframe\n",
    "        Filters college players in correct positions\n",
    "    \"\"\"\n",
    "    need_group = need_group.lower()\n",
    "    if \"qb\" in need_group:\n",
    "        positions = [\"QB\"]\n",
    "    elif \"rush\" in need_group and \"offense\" in need_group:\n",
    "        positions = [\"RB\", \"HB\", \"TB\"]\n",
    "    elif \"receiving\" in need_group or \"wr\" in need_group:\n",
    "        positions = [\"WR\", \"TE\"]\n",
    "    elif \"defense\" in need_group:\n",
    "        positions = [\"CB\", \"S\", \"DB\"]\n",
    "    elif \"pass rush\" in need_group or \"dl\" in need_group:\n",
    "        positions = [\"DE\", \"EDGE\", \"DT\", \"DL\", \"OLB\"]\n",
    "    else:\n",
    "        positions = []\n",
    "\n",
    "    if \"position\" in cfb_df.columns and positions:\n",
    "        mask = cfb_df[\"position\"].isin(positions)\n",
    "        out = cfb_df[mask].copy()\n",
    "        print(f\"[CFB] Filtered to {len(out)} players at positions {positions}\")\n",
    "        return out\n",
    "\n",
    "    print(\"[CFB] Could not filter by position; returning original df.\")\n",
    "    return cfb_df\n",
    "\n",
    "def rank_prospects(cfb_df, position_group, top_n=10):\n",
    "    \"\"\"\n",
    "    Rank college players for a given position group using appropriate stats.\n",
    "\n",
    "    Parameters\n",
    "    ----------\n",
    "    cfb_df : pd.DataFrame\n",
    "        Cleaned college player stats filtered to the relevant position group.\n",
    "    position_group : str\n",
    "        The abstract position group (e.g. \"QB\", \"WR\", \"EDGE\", \"CB\", \"S\").\n",
    "    top_n : int, optional\n",
    "        Number of top players to return, by default 10.\n",
    "\n",
    "    Returns\n",
    "    -------\n",
    "    pd.DataFrame\n",
    "        DataFrame of the top-ranked players including a computed score column.\n",
    "    \"\"\"\n",
    "    \n",
    "    #offsensive metrics\n",
    "    position_metrics = {\n",
    "        \"QB\": [\"PASS_YDS\", \"PASS_TD\", \"QBR\", \"CMP%\", \"ADOT\"],\n",
    "        \"WR\": [\"REC\", \"REC_YDS\", \"REC_TD\", \"YAC\"],\n",
    "        \"TE\": [\"REC\", \"REC_YDS\", \"REC_TD\"],\n",
    "        \"RB\": [\"RUSH_YDS\", \"RUSH_TD\", \"YAC\"],\n",
    "        \"OL\": [\"SACKS_ALLOWED\"],   # usually sparse; fallback handled later\n",
    "\n",
    "        # Defense\n",
    "        \"DL\": [\"SACK\", \"TFL\", \"TKL\"],\n",
    "        \"EDGE\": [\"SACK\", \"TFL\", \"TKL\"],\n",
    "        \"LB\": [\"TKL\", \"TFL\", \"INT\", \"PDEF\"],\n",
    "        \"CB\": [\"INT\", \"PDEF\", \"TKL\"],\n",
    "        \"S\": [\"INT\", \"PDEF\", \"TKL\"],\n",
    "    }\n",
    "\n",
    "    # Fallback if position group unknown\n",
    "    metrics = position_metrics.get(position_group, [])\n",
    "\n",
    "    # If no metrics available or missing in data\n",
    "    existing = [m for m in metrics if m in cfb_df.columns]\n",
    "\n",
    "    if not existing:\n",
    "        print(f\"[WARN] No metrics found for {position_group}, returning top players by name.\")\n",
    "        return cfb_df.head(top_n)\n",
    "\n",
    "    # Compute combined score\n",
    "    df = cfb_df.copy()\n",
    "    df[\"score_metric\"] = 0\n",
    "\n",
    "    for m in existing:\n",
    "        df[\"score_metric\"] += df[m].fillna(0)\n",
    "\n",
    "    ranked = rank_prospects(filtered, position_group=need_group, top_n=5)\n",
    "    return ranked\n",
    "\n",
    "\n",
    "\n",
    "def main() -> None:\n",
    "    _ensure_dir(RESULTS_DIR)\n",
    "\n",
    "    # 1) Load and compare Bears vs league\n",
    "    league_df, bears_df = load_nfl_data(season=2024)\n",
    "    z_df = standardize_metrics(league_df, bears_df)\n",
    "    z_path = os.path.join(RESULTS_DIR, \"bears_vs_league_zscores.csv\")\n",
    "    z_df.to_csv(z_path, index=False)\n",
    "    print(f\"Saved z-scores to {z_path}\")\n",
    "\n",
    "    group_df = infer_position_needs(z_df)\n",
    "    needs_path = os.path.join(RESULTS_DIR, \"position_group_needs.csv\")\n",
    "    group_df.to_csv(needs_path, index=False)\n",
    "    print(f\"Saved position group needs to {needs_path}\")\n",
    "\n",
    "    # Get top 3 most needed position groups\n",
    "    top_need_groups = pick_top_need_positions(group_df, k=3)\n",
    "\n",
    "    # 2) Use CFB stats to find prospects for each of those position groups\n",
    "    cfb_df = load_cfb_stats(year=2024)\n",
    "    if cfb_df.empty:\n",
    "        print(\"[CFB] No player stats loaded; skipping prospects.\")\n",
    "        return\n",
    "\n",
    "    all_ranked = []\n",
    "\n",
    "    for need_group in top_need_groups:\n",
    "        print(f\"\\n=== Processing prospects for need group: {need_group} ===\")\n",
    "        filtered = filter_prospects_for_position(cfb_df, need_group)\n",
    "        if filtered.empty:\n",
    "            print(f\"No CFB players found for group {need_group}, skipping.\")\n",
    "            continue\n",
    "\n",
    "        # Top 5 players for this position group\n",
    "        ranked = rank_prospects(filtered, need_group, top_n=5)\n",
    "        ranked[\"position_group_need\"] = need_group\n",
    "        all_ranked.append(ranked)\n",
    "\n",
    "    if not all_ranked:\n",
    "        print(\"No prospects found for any of the top need groups.\")\n",
    "        return\n",
    "\n",
    "    final_ranked = pd.concat(all_ranked, ignore_index=True)\n",
    "\n",
    "    prospects_path = os.path.join(\n",
    "        RESULTS_DIR, \"top_cfb_prospects_for_top3_needs.csv\"\n",
    "    )\n",
    "    final_ranked.to_csv(prospects_path, index=False)\n",
    "    print(f\"\\nSaved ranked prospects for top 3 needs to {prospects_path}\")\n",
    "\n",
    "\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
